# -*- coding: utf-8 -*-
"""
Created on Fri Jul 05 16:49:06 2022

@author: Ali Ghaffari       alg721@lehigh.edu

Agent-based model 
If IRR>0.08 then the agent will invest, otherwise it won't. Investment amount
is determined by a normal distribution of the existing capacity. Based on data, 
a typical solar system in the U.S. can produce electricity at the cost of $0.06 
to $0.08 per kilowatt-hour. With a payback period of 5.5 years in New Jersey, 
Massachusetts, and California, the ROI is 18.2% annually. In some other states, 
the payback period can be up to 12 years, which translates to an 8.5% annual return.
"""

### Calibration
# import libraries
import sys
import os
import numpy as np
import pandas as pd
import datetime
import pickle
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
sys.path.append(r'C:\Projects\ABM_PGMS\ABM')                                        # add to path
# import functions
from ABM_PGMS import read_data, supply_curve, generate_samples, ZoneInvest, \
    AgentInvest, aggregate, KGE_stat

#%% date
today = datetime.datetime.now()                                                     # create date object
date_now = today.strftime("%b-%d %H-%M")                                            # save date object as string
print("Today's date:", today)                                                       # output date

#%% read data files
# directories
os.chdir(r'C:\Projects\ABM_PGMS\ABM')                                               # change working directory
data_dir = r'C:\Projects\ABM_PGMS\ABM\Calibration_Data'                             # data directory
result_dir = r'C:\Projects\ABM_PGMS\ABM\Results\Historical_Analysis'                # results directory
demand_monthly = pd.read_csv(os.path.join(data_dir, 'demand_monthly.csv'))          # monthly demand data
price_monthly = pd.read_csv(os.path.join(data_dir, 'price_monthly.csv'))            # monthly price data
Demand = read_data(os.path.join(data_dir, 'demand_total.csv'))                      # read annual total demand (MWh) [Year,Demand]
Demand = Demand.set_index('Year')                                                   # set 'Year' columns as index
CF = read_data(os.path.join(data_dir, 'historical_capacity_factor_ABM.csv'))        # read capacity factor (%) [Year, NG, Wind, Solar, Battery] 
CP = read_data(os.path.join(data_dir, 'new_capacity_edited.csv'))                   # read new capacity (MW) by technology type [Year, NG, Solar, Wind, Total]
CA = read_data(os.path.join(data_dir, 'Retirement_Total_capacity.csv'))             # read retired, new, and total capacity (MW) [Year, New, Retired, Total]
CA = CA.set_index('Year')                                                           # set 'Year' column as index
G_hist_cost = read_data(os.path.join(data_dir, 'historical_cost_data.csv'))         # read total cost ($/MW) [Year, NG, Solar, Wind]
Retire = pd.read_csv(os.path.join(data_dir, 'Retire_hist.csv'), index_col='Year')   # historical retired capacity

#%% model initialization                                    
# create a dict to store lifespan, cost, and capacity factor for all technologies
# lifespan based on Ziegler et. al, 2018; capacity factor based on 2019 data
data = {'NG':[30, 1.510*1E6*1.1, 56.6],                                             # $917 in 2012 = $1510 in 2020 (5% interest rate); 10% O&M costs                                                             
        'Solar':[25, G_hist_cost['Solar'][0], 24.9],                                # solar price in 2000
        'Wind':[30, G_hist_cost['Wind'][0], 35.4]}                                  # wind price in 2000
df_G = pd.DataFrame.from_dict(data)                                                 # save data into a dataframe
df_G.index = ['LS','Cost','CF']                                                     # add indices to the dataframe

# parameters
n_agt = 161                                                                         # number of agents; 74/161 are wind/solar, 8 solar only, which makes 82/161 ~= 50%
renewable = int(0.5*n_agt)                                                          # number of renewalbe companies 
REC_p = 15                                                                          # Renewable Energy Credit price ($/MW)
LZ = ['LZ_AEN','LZ_CPS','LZ_HOUSTON','LZ_NORTH','LZ_SOUTH','LZ_WEST']               # load zones 
d_percent = [0.04,0.06,0.27,0.33,0.13,0.12]                                         # percentage to total demand based on 2020 data
D_zone_percent = pd.DataFrame(d_percent, index = LZ, columns = ['D_perc'])          # demand percentage dataframe
IRR_threshold = 0.08                                                                # IRR threshold (decision criteria) 
T = 10                                                                              # simulation time: 10 years 

#%% Calibration 
# in this section, random data is generated by gamma and normal distributions
# to save size, risk, REC, and cost perceived by different agent types. For
# each set of parameters, the code runs for 10 simluations to capture the
# stochasticity of the model. Finally, the model with the best of set of
# parameters will be selected to simulate future scenarios.

# read historical data for comparison at the end   
cap_hist = CP.iloc[12:,:]                                                           # historical new and total capacity 
cap_retired = CA.iloc[13:,1:]                                                       # the capacity retired from 2012 - 2020 and the total capacity
# create empty lists to store data
R = []                                                                              # Pearson Coefficient of Correllation
KGE= []                                                                             # Kling-Gupta Efficiency (KGE) values
# P = []                                                                              # P-value

risk_values = [0.2, 0.4, 0.6, 0.8, 1.0, -99]                                        # first 5 values are predefined risk perceptions for all agents; -99 is for the calibrated scenario
df_dict = dict((x, pd.DataFrame()) for x in ['NG', 'Solar', 'Wind', 'Total_cum'])   # create a dict with 4 dataframes to store data for plotting
dist_params = [0.84, 0.07, 0.38, 0.08, 6, 6]                                        # distribution parameters = [mu_wind, sd_wind, mu_solar, sd_solar]
dist_cost, dist_RSR = generate_samples(dist_params, result_dir, renewable, 
                                   n_agt,date_now,0)                                # generate two dictionaries containing required random
for k in range(6):                                                                  # test 5 different values for risk between 0.1 and 1 with an interval of 0.2                                                         
    result = []                                                                     # create a list to store results
    r = risk_values[k]                                                              # set risk to predefined values
    ng_cost_dist = dist_cost["NG"]                                                  # NG cost
    solar_cost_dist = dist_cost["Solar"]                                            # solar cost
    wind_cost_dist = dist_cost["Wind"]                                              # wind cost
    if k==5:                                                                        # k=5 is for the calibrated risk values
        risk_dist = dist_RSR["risk"]                                                # agents' risk perception distribution
    else:
        risk_dist = r*np.ones(n_agt)                                                # constant predefined risk perception for all agents
    size_dist = dist_RSR["size"]                                                    # agents' size distribution
    rec_dist = dist_RSR["REC"]                                                      # agents' REC distribution

    # historical investment simulation
    agt_rec = REC_p*rec_dist                                                        # financial incentive for each agent
    frame = []                                                                      # create a list to store investment decisions
    row_list = []                                                                   # create a list to store investment decisions for each year
    tot_ca = CA.loc[2011][2]                                                        # total planned generation capacity in 2011 = 109179 MW
    tot_new_ca = []                                                                 # new total capacity installed each year

    for t in range(9):                                                              # zonal demand data only available from 2011 to 2020
        y = 2012 + t                                                                # year
        new_D = Demand.loc[y].values                                                # annual total demand for year y
        new_cost = G_hist_cost.iloc[:,1:][G_hist_cost["Year($MW)"] == y]            # remove column 'Year' and select the cost data for year y
        cap_predicted = new_D*0.00029 + 5638                                        # capacity prediction using demand forecast data (actual historical demand)
        cap_deficit = cap_predicted - tot_ca + CA.loc[y][1]                         # capacity_deficit = predicted_cpacity - current_capacity + retired_capacity
        if cap_deficit < 0:                                                         # if no demand for capacity, no investment
            cap_deficit = 0
        linear = supply_curve(LZ, y)                                                # supply curves [slope, intercept] of the load zones
        cap_deficit_agt = cap_deficit*size_dist                                     # capacity deficit for each agent
        new_capacity = 0                                                            # initial new capacity investment by each agent
        for agt_i in range(n_agt):                                                  # loop over agents
            IRR_t = []                                                              # create a list to store IRR values
            G_tech_lz = []                                                          # create a list to store technology types
            tech_row = {'Year':y, 'Agent':str(agt_i)}                               # a row that records investment technology for each load zone
            new_cost_dict = {"NG":new_cost["NG"].values[0]*ng_cost_dist[agt_i],     # create a dictionary to store cost values for each technology
                             "Solar":new_cost["Solar"].values[0]*solar_cost_dist[agt_i],
                             "Wind":new_cost["Wind"].values[0]*wind_cost_dist[agt_i]}
            df_G.loc['Cost'] = new_cost_dict                                        # update cost
    
            for i in range(len(LZ)):                                                # loop over load zones
                c1,c2 = linear[i]                                                   # slope and intercept (price = a*demand + b)
                c3 = 0                                                              # scalar for agent's prediction error   
                # predicted average price for a load zone; new_d is divided by
                # 12 because new_d is annual but the price prediction from the
                # supply curve is based on monthly data
                new_P = c1*new_D/12*D_zone_percent.loc[LZ[i]].values[0] + c2
                rec_p = agt_rec[agt_i]                                              # REC value for the selected agent
                G_tech, max_IRR = ZoneInvest(new_P, rec_p, df_G)                    # determine the investment technology and the corresponding IRR
                new_row = {'Year':y, 'Agent':str(agt_i), 'LZ':LZ[i],                # add investment decision results to new_row
                           'Tech':G_tech, 'IRR':max_IRR} 
                tech_row[LZ[i]+"_fuel"] = G_tech                                    # add the investment technology in the LZ to tech_row dictionary
                IRR_t.append(max_IRR)                                               # append the generated IRR to the IRR list
                row_list.append(new_row)                                            # append updated new_row to row_list
            IRR_t_array = np.array(IRR_t)                                           # convert IRR_t list to array
            agt_capacity_invest = cap_deficit_agt[agt_i]*risk_dist[agt_i]           # investment amount is discounted because of risk aversion. IOW,
                                                                                    # the agent will invest less than the needed capacity (hesitation).
            lz_invest = AgentInvest(LZ, IRR_t_array, agt_capacity_invest,           # determine agent's investment in each load zone
                                    IRR_threshold)
            lz_invest_agt_sum = np.sum([*lz_invest.values()])                       # sum the capacity invested in load zones by the agent
            new_capacity += lz_invest_agt_sum                                       # add the agent's invested capacity to the total new capacity
            lz_invest.update(tech_row)                                              # update lz_invest dict
            frame.append(lz_invest)                                                 # append investment by load zones to frame list
        
    tot_ca = tot_ca + new_capacity - cap_retired.loc[y][0]                          # add new capacity and subtract retirement
    tot_new_ca.append(tot_ca)                                                       # append new installed capacity to total new capacity
    
    result = pd.DataFrame(frame)                                                    # save frame to a dataframe
    cap_initial = CP.iloc[11,4]                                                     # extract initial cap for 2011
    agg_tech, agg_year, agg_LZ = aggregate(n_agt, result, Retire, 2012, cap_initial)# aggregate investment decisions by technology, year, and load zone
    # save results to excel files                                                     
    agg_tech_file = os.path.join(result_dir, date_now, "agg_tech" + str(k) +".csv")
    agg_tech.to_csv(agg_tech_file)                                                  # agg_tech: investment by technology types
    agg_year_file = os.path.join(result_dir, date_now, "agg_year" + str(k) +".csv")
    agg_year.to_csv(agg_year_file)                                                  # agg_year: investment by year
    agg_LZ_file = os.path.join(result_dir, date_now, "agg_LZ" + str(k) +".csv")
    agg_LZ.to_csv(agg_LZ_file)                                                      # agg_LZ: investment by load zone
    tech_cumulative = agg_year.sum()                                                # cumulative investment in MW at the end of 2020

    df_name = str(k)                                                                # create a column name based on k
    for x in ['NG', 'Solar', 'Wind', 'Total_cum']:                                  # loop over output plots
        df_dict[x][df_name] = agg_year[x]                                           # append agg_year data to plot dictionary
        
with open(os.path.join(result_dir, date_now,'df_dict.pkl'), 'wb') as file:              # save df_dict to pickle file
    pickle.dump(df_dict, file)

#%% Plots
time = np.arange(2012, 2021)
df = CP.iloc[-9:,:]
fig, axs = plt.subplots(2, 2)
colors = ['y','c','m','b','r','g']
for k in range(6):                                                                  # loop over risk perception values
    df_name = str(k)                                                   # create column name for data
    axs[0,0].plot(time, df_dict['NG'][df_name], color=colors[k])                # NG
    axs[0,1].plot(time, df_dict['Solar'][df_name], color=colors[k])             # Solar
    axs[1,0].plot(time, df_dict['Wind'][df_name], color=colors[k])              # Wind
    axs[1,1].plot(time, df_dict['Total_cum'][df_name], color=colors[k])         # Total
# axs[0, 0].plot(time, df['NG'], color='k')                                           # historical NG  
axs[0, 0].set_title('NG')                                                           
# axs[0, 1].plot(time, df['Solar'], color='k')                                        # historical Solar   
axs[0, 1].set_title('Solar')    
# axs[1, 0].plot(time, df['Wind'], color='k')                                         # historical Wind
axs[1, 0].set_title('Wind')
# axs[1, 1].plot(time, df['Total'], color='k')                                        # historical Total
axs[1, 1].set_title('Total')

# create label for colors
y_patch = mpatches.Patch(color='y', label='r=0.2')
c_patch = mpatches.Patch(color='c', label='r=0.4')
m_patch = mpatches.Patch(color='m', label='r=0.6')
b_patch = mpatches.Patch(color='b', label='r=0.8')
r_patch = mpatches.Patch(color='r', label='r=1.0')
g_patch = mpatches.Patch(color='g', label='calibrated r')
# k_patch = mpatches.Patch(color='k', label='historical r')
axs[0,1].legend(handles=[y_patch, c_patch, m_patch, b_patch, r_patch, g_patch],     # only put legend for axs[0,1]
                        loc=2, fontsize='xx-small')

for ax in axs.flat:                                                                 
    ax.set(xlabel='Year', ylabel='Capacity (MW)')                                   # set labels for x and y   
    ax.label_outer()                                                                # hide x labels and tick labels for top plots and y ticks for right plots
fig.savefig(os.path.join(result_dir, date_now, 'Result' + date_now[-5:] + 
                         '.png'), bbox_inches='tight', dpi=300)